
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ì–¼êµ´ ì¸ìƒ ë¶„ì„ ë°ëª¨</title>
  <style>
    body { font-family: sans-serif; margin: 0; text-align: center; }
    canvas { position: absolute; left: 0; top: 0; z-index: 1; }
    video { position: absolute; left: 0; top: 0; visibility: hidden; }
    #result { position: relative; margin-top: 500px; font-size: 1.2em; }
  </style>
</head>
<body>
  <h2>ğŸ“· ì–¼êµ´ ì¸ìƒ ë¶„ì„ ë°ëª¨</h2>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas" width="640" height="480"></canvas>
  <div id="result">ê²°ê³¼ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</div>

  <!-- ìµœì‹  Mediapipe ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    const videoElement = document.getElementById('video');
    const canvasElement = document.getElementById('canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const resultDiv = document.getElementById('result');

    function getDistance(p1, p2) {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateScores(landmarks) {
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const noseTip = landmarks[1];
      const chin = landmarks[152];

      const eyeDistance = getDistance(leftEye, rightEye);
      const faceLength = getDistance(noseTip, chin);

      let score = {};

      if (eyeDistance < 0.10) {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 0;
      } else if (eyeDistance < 0.13) {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 1;
      } else {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 2;
      }

      const ratio = faceLength / eyeDistance;
      if (ratio > 2.5) {
        score["ì–¼êµ´í˜•"] = 2;
      } else if (ratio > 2.0) {
        score["ì–¼êµ´í˜•"] = 1;
      } else {
        score["ì–¼êµ´í˜•"] = 0;
      }

      return score;
    }

    function classifyType(score) {
      if (score["ì–¼êµ´í˜•"] === 2 && score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] === 0) {
        return "ğŸ–¤ ë„ë„ ì‹œí¬í˜•: ë„ì‹œì ì´ê³  ë˜ë ·í•œ ì¸ìƒì…ë‹ˆë‹¤.";
      } else if (score["ì–¼êµ´í˜•"] === 0 && score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] === 2) {
        return "ğŸ’– ëŸ¬ë¸”ë¦¬ ë™ì•ˆí˜•: ë‘¥ê¸€ê³  ê·€ì—¬ìš´ ì¸ìƒì…ë‹ˆë‹¤.";
      } else {
        return "âœ¨ ì„¸ë ¨ ë°¸ëŸ°ìŠ¤í˜•: ì•ˆì •ì ì´ê³  ì¡°í™”ë¡œìš´ ì¸ìƒì…ë‹ˆë‹¤.";
      }
    }

    const faceMesh = new FaceMesh({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    faceMesh.onResults((results) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(
        results.image,
        0,
        0,
        canvasElement.width,
        canvasElement.height
      );

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        for (const landmarks of results.multiFaceLandmarks) {
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {
            color: "#00FF00",
            lineWidth: 0.5,
          });
          drawLandmarks(canvasCtx, landmarks, {
            color: "#FF0000",
            radius: 1.5,
          });

          const score = calculateScores(landmarks);
          const resultText = classifyType(score);
          resultDiv.innerText = resultText;
        }
      }
      canvasCtx.restore();
    });

    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 640,
      height: 480,
    });

    camera.start();
  </script>
</body>
</html>
