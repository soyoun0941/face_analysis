
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì–¼êµ´ ì¸ìƒ ë¶„ì„ ë°ëª¨</title>
  <style>
    body { font-family: sans-serif; margin: 0; padding: 0; text-align: center; }
    video, canvas { position: absolute; left: 0; top: 0; }
    #result { position: relative; margin-top: 500px; font-size: 1.2em; }
  </style>
</head>
<body>
  <h2>ğŸ“· ì–¼êµ´ ì¸ìƒ ë¶„ì„ ë°ëª¨</h2>
  <video class="input_video" autoplay muted playsinline width="640" height="480"></video>
  <canvas class="output_canvas" width="640" height="480"></canvas>
  <div id="result">ê²°ê³¼ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.4/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.4/camera_utils.min.js"></script>

  <script>
    const videoElement = document.querySelector('.input_video');
    const canvasElement = document.querySelector('.output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const resultDiv = document.getElementById('result');

    function getDistance(p1, p2) {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateScores(landmarks) {
      const leftEye = landmarks[33];
      const rightEye = landmarks[263];
      const noseTip = landmarks[1];
      const chin = landmarks[152];

      const eyeDistance = getDistance(leftEye, rightEye);
      const faceLength = getDistance(noseTip, chin);

      let score = {};

      if (eyeDistance < 0.10) {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 0;
      } else if (eyeDistance < 0.13) {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 1;
      } else {
        score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] = 2;
      }

      const ratio = faceLength / eyeDistance;
      if (ratio > 2.5) {
        score["ì–¼êµ´í˜•"] = 2;
      } else if (ratio > 2.0) {
        score["ì–¼êµ´í˜•"] = 1;
      } else {
        score["ì–¼êµ´í˜•"] = 0;
      }

      return score;
    }

    function classifyType(score) {
      if (score["ì–¼êµ´í˜•"] === 2 && score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] === 0) {
        return "ğŸ–¤ ë„ë„ ì‹œí¬í˜•: ë„ì‹œì ì´ê³  ë˜ë ·í•œ ì¸ìƒì…ë‹ˆë‹¤.";
      } else if (score["ì–¼êµ´í˜•"] === 0 && score["ëˆˆ ì‚¬ì´ ê±°ë¦¬"] === 2) {
        return "ğŸ’– ëŸ¬ë¸”ë¦¬ ë™ì•ˆí˜•: ë‘¥ê¸€ê³  ê·€ì—¬ìš´ ì¸ìƒì…ë‹ˆë‹¤.";
      } else {
        return "âœ¨ ì„¸ë ¨ ë°¸ëŸ°ìŠ¤í˜•: ì•ˆì •ì ì´ê³  ì¡°í™”ë¡œìš´ ì¸ìƒì…ë‹ˆë‹¤.";
      }
    }

    const faceMesh = new FaceMesh.FaceMesh({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    faceMesh.onResults((results) => {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        for (const landmarks of results.multiFaceLandmarks) {
          window.drawConnectors(canvasCtx, landmarks, window.FACEMESH_TESSELATION,
            { color: '#00FF00', lineWidth: 0.5 });
          window.drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', radius: 1.5 });

          const score = calculateScores(landmarks);
          const resultText = classifyType(score);
          resultDiv.innerText = resultText;
        }
      }
      canvasCtx.restore();
    });

    const camera = new Camera.Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({ image: videoElement });
      },
      width: 640,
      height: 480
    });
    camera.start();
  </script>
</body>
</html>
